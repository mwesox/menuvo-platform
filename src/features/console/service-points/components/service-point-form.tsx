import { useForm } from "@tanstack/react-form";
import { useSuspenseQuery } from "@tanstack/react-query";
import { useState } from "react";
import { useTranslation } from "react-i18next";
import { Button } from "@/components/ui/button.tsx";
import {
	Field,
	FieldError,
	FieldGroup,
	FieldLabel,
} from "@/components/ui/field.tsx";
import { Input } from "@/components/ui/input.tsx";
import { Textarea } from "@/components/ui/textarea.tsx";
import type { ServicePoint } from "@/db/schema.ts";
import {
	servicePointQueries,
	useCreateServicePoint,
	useUpdateServicePoint,
} from "../queries.ts";
import { AttributesEditor } from "./attributes-editor.tsx";

interface ServicePointFormProps {
	storeId: string;
	servicePoint?: ServicePoint;
	onSuccess?: () => void;
	onCancel?: () => void;
}

function generateCode(name: string): string {
	return name
		.toLowerCase()
		.replace(/[^a-z0-9]+/g, "-")
		.replace(/^-|-$/g, "");
}

export function ServicePointForm({
	storeId,
	servicePoint,
	onSuccess,
	onCancel,
}: ServicePointFormProps) {
	const { t } = useTranslation("servicePoints");
	const isEditing = !!servicePoint;
	const createMutation = useCreateServicePoint(storeId);
	const updateMutation = useUpdateServicePoint(storeId);

	// Get existing zones for suggestions
	const { data: existingZones } = useSuspenseQuery(
		servicePointQueries.zones(storeId),
	);

	const [autoGenerateCode, setAutoGenerateCode] = useState(!isEditing);

	const form = useForm({
		defaultValues: {
			name: servicePoint?.name ?? "",
			code: servicePoint?.code ?? "",
			zone: servicePoint?.zone ?? "",
			description: servicePoint?.description ?? "",
			attributes: (servicePoint?.attributes ?? {}) as Record<
				string,
				string | number | boolean
			>,
		},
		onSubmit: async ({ value }) => {
			try {
				if (isEditing) {
					await updateMutation.mutateAsync({
						id: servicePoint.id,
						...value,
						zone: value.zone || undefined,
						description: value.description || undefined,
						attributes:
							Object.keys(value.attributes).length > 0
								? value.attributes
								: undefined,
					});
				} else {
					await createMutation.mutateAsync({
						...value,
						zone: value.zone || undefined,
						description: value.description || undefined,
						attributes:
							Object.keys(value.attributes).length > 0
								? value.attributes
								: undefined,
					});
				}
				onSuccess?.();
			} catch {
				// Error already handled by mutation
			}
		},
	});

	// Auto-generate code from name when name field changes
	const handleNameChange = (name: string) => {
		if (autoGenerateCode) {
			form.setFieldValue("code", generateCode(name));
		}
	};

	return (
		<form
			onSubmit={(e) => {
				e.preventDefault();
				form.handleSubmit();
			}}
			className="space-y-6"
		>
			<FieldGroup>
				<form.Field name="name">
					{(field) => {
						const isInvalid =
							field.state.meta.isTouched && !field.state.meta.isValid;
						return (
							<Field data-invalid={isInvalid}>
								<FieldLabel htmlFor={field.name}>
									{t("labels.name")} *
								</FieldLabel>
								<Input
									id={field.name}
									name={field.name}
									placeholder={t("placeholders.name")}
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => {
										field.handleChange(e.target.value);
										handleNameChange(e.target.value);
									}}
									aria-invalid={isInvalid}
								/>
								{isInvalid && <FieldError errors={field.state.meta.errors} />}
							</Field>
						);
					}}
				</form.Field>

				<form.Field name="code">
					{(field) => {
						const isInvalid =
							field.state.meta.isTouched && !field.state.meta.isValid;
						return (
							<Field data-invalid={isInvalid}>
								<FieldLabel htmlFor={field.name}>
									{t("labels.urlCode")} *
									{autoGenerateCode && (
										<span className="ms-2 text-muted-foreground text-xs">
											{t("labels.autoGenerated")}
										</span>
									)}
								</FieldLabel>
								<Input
									id={field.name}
									name={field.name}
									placeholder={t("placeholders.code")}
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => {
										field.handleChange(e.target.value);
										if (autoGenerateCode) setAutoGenerateCode(false);
									}}
									aria-invalid={isInvalid}
								/>
								<p className="text-muted-foreground text-xs">
									{t("hints.urlCode")}
								</p>
								{isInvalid && <FieldError errors={field.state.meta.errors} />}
							</Field>
						);
					}}
				</form.Field>

				<form.Field name="zone">
					{(field) => {
						const isInvalid =
							field.state.meta.isTouched && !field.state.meta.isValid;
						return (
							<Field data-invalid={isInvalid}>
								<FieldLabel htmlFor={field.name}>{t("labels.zone")}</FieldLabel>
								<Input
									id={field.name}
									name={field.name}
									placeholder={t("placeholders.zone")}
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
									list="zone-suggestions"
									aria-invalid={isInvalid}
								/>
								{existingZones && existingZones.length > 0 && (
									<datalist id="zone-suggestions">
										{existingZones.map((zone) => (
											<option key={zone} value={zone} />
										))}
									</datalist>
								)}
								<p className="text-muted-foreground text-xs">
									{t("hints.zone")}
								</p>
								{isInvalid && <FieldError errors={field.state.meta.errors} />}
							</Field>
						);
					}}
				</form.Field>

				<form.Field name="description">
					{(field) => {
						const isInvalid =
							field.state.meta.isTouched && !field.state.meta.isValid;
						return (
							<Field data-invalid={isInvalid}>
								<FieldLabel htmlFor={field.name}>
									{t("labels.description")}
								</FieldLabel>
								<Textarea
									id={field.name}
									name={field.name}
									placeholder={t("placeholders.description")}
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
									rows={2}
									aria-invalid={isInvalid}
								/>
								{isInvalid && <FieldError errors={field.state.meta.errors} />}
							</Field>
						);
					}}
				</form.Field>

				<form.Field name="attributes">
					{(field) => (
						<Field>
							<FieldLabel>{t("labels.attributes")}</FieldLabel>
							<AttributesEditor
								value={field.state.value}
								onChange={field.handleChange}
							/>
						</Field>
					)}
				</form.Field>
			</FieldGroup>

			<form.Subscribe selector={(state) => state.isSubmitting}>
				{(isSubmitting) => (
					<div className="flex justify-end gap-2">
						{onCancel && (
							<Button type="button" variant="outline" onClick={onCancel}>
								{t("buttons.cancel")}
							</Button>
						)}
						<Button type="submit" disabled={isSubmitting}>
							{isSubmitting
								? isEditing
									? t("buttons.updating")
									: t("buttons.creating")
								: isEditing
									? t("buttons.update")
									: t("buttons.create")}
						</Button>
					</div>
				)}
			</form.Subscribe>
		</form>
	);
}
